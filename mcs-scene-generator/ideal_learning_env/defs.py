import random
from abc import ABC, abstractmethod
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Type,
    Union,
    get_args,
    get_origin,
    get_type_hints
)

from generator import (
    MAX_TRIES,
    MaterialTuple,
    ObjectBounds,
    ObjectDefinition,
    geometry
)
from generator.materials import find_colors
from generator.scene import Scene

ROOM_MAX_XZ = 100
ROOM_MIN_XZ = 2
ROOM_MAX_Y = 10
ROOM_MIN_Y = 2

# All goal targets will be assigned this label automatically
TARGET_LABEL = "target"


class ILEException(Exception):
    def __init__(self, message: str = ''):
        super().__init__(message)


class ILEDelayException(ILEException):
    """Exception to indicate that the current action may be able to be
    performed after another component completes its actions."""
    ...


class ILEConfigurationException(ILEException):
    """Configuration exceptions should be thrown when the ILE configuration
    file has been configured in a way that cannot be processed and no retries
    are necessary.

    For example, if a goal target is required, but no goal target has been
    configured, the ILE Scene Generator should fail with this exception.
    """

    def __init__(self, message: str = ''):
        super().__init__(message)


class ILESharedConfiguration():
    """Manages ILE configuration options shared across multiple components."""
    __instance = None

    @staticmethod
    def get_instance():
        """ Static access method. """
        if ILESharedConfiguration.__instance is None:
            ILESharedConfiguration()
        return ILESharedConfiguration.__instance

    def __init__(self):
        """ Virtually private constructor. """
        if ILESharedConfiguration.__instance is not None:
            raise Exception("This class is a singleton!")
        else:
            ILESharedConfiguration.__instance = self

    _excluded_shapes = []

    def choose_definition_from_included_shapes(
        self,
        callback: Callable[[], ObjectDefinition],
        args={}
    ) -> ObjectDefinition:
        """Runs the given callback function repeatedly to randomly choose an
        ObjectDefinition with a valid type/shape that has not been specifically
        excluded via the configuration, and returns that ObjectDefinition, or
        raises an exception if it fails."""
        for _ in range(MAX_TRIES):
            definition = callback(**args)
            if definition.type not in self._excluded_shapes:
                return definition
        raise ILEException(
            f'Failed to choose a random object type/shape, probably due '
            f'to the user-configured excluded_shapes: {self._excluded_shapes}'
        )

    def get_excluded_shapes(self) -> List[str]:
        """Returns all the object types specifically excluded from being
        randomly generated by the current ILE configuration."""
        return self._excluded_shapes

    def is_excluded_shapes(self, shape: str) -> bool:
        """Returns whether the given object type is specifically excluded from
        being randomly generated by the current ILE configuration."""
        return shape in self._excluded_shapes

    def set_excluded_shapes(self, excluded_shapes: List[str]) -> None:
        """Sets all the object types specifically excluded from being randomly
        generated by the current ILE configuration."""
        self._excluded_shapes = excluded_shapes


class ConverterClass(ABC):
    """Used when a class in the config file needs to be changed to another
    when chosen.  An example would be VectorFloatConfig converted to
    Vector3D."""

    @abstractmethod
    def convert_value(self) -> Any:
        """Return an instance of this object with its converted class."""
        return None


def choose_random(data: Any, data_type: Type = None) -> Any:
    """Return the data, if it's a single choice; a single element from the
    data, if it's a list; or a value within a numeric range, if it's a MinMax.
    The given type is used to handle specific edge cases."""
    output_typing: Type = (
        get_args(data_type)[0] if get_origin(data_type) == Union else data_type
    )
    choice = data

    # If the data's a list, choose a random item from the list.
    if isinstance(choice, list):
        # Don't return the choice; let this function continue to act upon it.
        choice = random.choice(choice)

    # If the data's a ConverterClass, let it handle its own conversion.
    if isinstance(choice, ConverterClass):
        return choice.convert_value()

    # If the data's not None and not a primitive type, assume it's a class.
    if choice and not isinstance(choice, (dict, float, int, str, tuple)):
        data_class = type(choice)
        data_typings: Dict[str, Type] = get_type_hints(choice.__class__)
        data_choices: Dict[str, Any] = {}
        # Choose random values for each nested property in the class.
        for prop, typing in data_typings.items():
            data_choices[prop] = choose_random(getattr(choice, prop), typing)
        return data_class(**data_choices)

    # If the typing is MaterialTuple, assume the data's either a str or tuple.
    if output_typing == MaterialTuple:
        if isinstance(choice, MaterialTuple):
            return choice
        if isinstance(choice, tuple):
            # I don't think we need this any more, but just in case...
            return MaterialTuple(choice[0], choice[1])
        return MaterialTuple(choice, find_colors(choice))

    return choice


def find_bounds(
    scene: Scene,
    ignore_ground: bool = False
) -> List[ObjectBounds]:
    """Calculate and return the bounds for all the given objects."""
    # Create a bounding box for each hole and lava area and add it to the list.
    bounds = [] if ignore_ground else [
        geometry.generate_floor_area_bounds(area['x'], area['z'])
        for area in (scene.holes + scene.lava)
    ]

    if scene.partition_floor and not ignore_ground:
        bounds += geometry.find_partition_floor_bounds(
            scene.room_dimensions, scene.partition_floor)

    # Add each object's bounding box to the list.
    for instance in scene.objects:
        try:
            bounds.append(instance['shows'][0]['boundingBox'])
        except(KeyError):
            ...
    return bounds


def return_list(data: Any, default_value: Any = None) -> List[Any]:
    """Return the given data as a list if it's not already one; return an empty
    list, or the given default value, if the data is None."""
    if data is None:
        return [] if default_value is None else default_value
    if not isinstance(data, list):
        return [data]
    return data


RandomizableBool = Union[bool, List[bool]]
RandomizableString = Union[str, List[str]]
